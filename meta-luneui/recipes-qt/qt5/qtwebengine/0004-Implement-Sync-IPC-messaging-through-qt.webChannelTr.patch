From d5775bd639fa3859485d3e8dbbfd88af139177c5 Mon Sep 17 00:00:00 2001
From: Christophe Chapuis <chris.chapuis@gmail.com>
Date: Wed, 30 Sep 2015 19:48:02 +0200
Subject: [PATCH] Implement Sync IPC messaging through
 qt.webChannelTransport.sendSync

Signed-off-by: Christophe Chapuis <chris.chapuis@gmail.com>
---
 src/core/common/qt_messages.h                 |  2 +
 .../renderer/web_channel_ipc_transport.cpp    | 39 +++++++++++++++++++
 .../web_channel_ipc_transport_host.cpp        | 17 +++++++-
 .../web_channel_ipc_transport_host.h          |  3 ++
 4 files changed, 60 insertions(+), 1 deletion(-)

diff --git a/src/core/common/qt_messages.h b/src/core/common/qt_messages.h
index c5caa0ff..d3382dba 100644
--- a/src/core/common/qt_messages.h
+++ b/src/core/common/qt_messages.h
@@ -76,6 +76,8 @@ IPC_MESSAGE_ROUTED0(RenderViewObserverHostQt_DidFirstVisuallyNonEmptyLayout)
 
 IPC_MESSAGE_ROUTED1(WebChannelIPCTransportHost_SendMessage, std::vector<char> /*binaryJSON*/)
 
+IPC_SYNC_MESSAGE_ROUTED1_1(WebChannelIPCTransportHost_SendMessageSync, std::vector<char> /*binaryJSON*/, std::vector<char> /*binaryJSON*/)
+
 //-----------------------------------------------------------------------------
 // Misc messages
 // These are messages sent from the renderer to the browser process.
diff --git a/src/core/renderer/web_channel_ipc_transport.cpp b/src/core/renderer/web_channel_ipc_transport.cpp
index bb544168..02907a2a 100644
--- a/src/core/renderer/web_channel_ipc_transport.cpp
+++ b/src/core/renderer/web_channel_ipc_transport.cpp
@@ -69,6 +69,44 @@ private:
     // gin::WrappableBase
     gin::ObjectTemplateBuilder GetObjectTemplateBuilder(v8::Isolate *isolate) override;
 
+    void NativeQtSendMessageSync(gin::Arguments *args)
+    {
+        content::RenderView *renderView = GetRenderView(args->isolate());
+        if (!renderView || args->Length() != 1)
+            return;
+        v8::Handle<v8::Value> val;
+        args->GetNext(&val);
+        if (!val->IsString() && !val->IsStringObject())
+            return;
+        v8::String::Utf8Value utf8(val->ToString());
+
+        QByteArray valueData(*utf8, utf8.length());
+        QJsonParseError error;
+        QJsonDocument doc = QJsonDocument::fromJson(valueData, &error);
+        if (error.error != QJsonParseError::NoError)
+            qWarning("%s %d: Parsing error: %s",__FILE__, __LINE__, qPrintable(error.errorString()));
+        int size = 0;
+        const char *rawData = doc.rawData(&size);
+
+        std::vector<char> replyData;
+        WebChannelIPCTransportHost_SendMessageSync *message = new WebChannelIPCTransportHost_SendMessageSync(renderView->GetRoutingID(), std::vector<char>(rawData, rawData + size), &replyData);
+        // Enable the UI thread in browser to receive messages.
+        message->EnableMessagePumping();
+        renderView->Send(message);
+
+        QJsonDocument docReply = QJsonDocument::fromRawData(replyData.data(), replyData.size(), QJsonDocument::BypassValidation);
+        Q_ASSERT(docReply.isObject());
+        QByteArray jsonReply = docReply.toJson(QJsonDocument::Compact);
+
+        v8::Isolate *isolate = v8::Isolate::GetCurrent();
+        v8::Handle<v8::Object> replyObject(v8::Object::New(isolate));
+        replyObject->ForceSet(v8::String::NewFromUtf8(isolate, "data")
+                           , v8::String::NewFromUtf8(isolate, jsonReply.constData(), v8::String::kNormalString, jsonReply.size())
+                           , v8::PropertyAttribute(v8::ReadOnly | v8::DontDelete));
+
+        args->Return(replyObject);
+    }
+
     DISALLOW_COPY_AND_ASSIGN(WebChannelTransport);
 };
 
@@ -155,6 +193,7 @@ gin::ObjectTemplateBuilder WebChannelTransport::GetObjectTemplateBuilder(v8::Iso
 {
     return gin::Wrappable<WebChannelTransport>::GetObjectTemplateBuilder(isolate)
         .SetMethod("send", &WebChannelTransport::NativeQtSendMessage);
+        .SetMethod("sendSync", &WebChannelTransport::NativeQtSendMessageSync);
 }
 
 WebChannelIPCTransport::WebChannelIPCTransport(content::RenderFrame *renderFrame)
diff --git a/src/core/renderer_host/web_channel_ipc_transport_host.cpp b/src/core/renderer_host/web_channel_ipc_transport_host.cpp
index 6b32093a..00578bab 100644
--- a/src/core/renderer_host/web_channel_ipc_transport_host.cpp
+++ b/src/core/renderer_host/web_channel_ipc_transport_host.cpp
@@ -70,6 +70,7 @@ inline QDebug operator<<(QDebug stream, const base::Optional<T> &opt)
 WebChannelIPCTransportHost::WebChannelIPCTransportHost(content::WebContents *contents, uint worldId, QObject *parent)
     : QWebChannelAbstractTransport(parent)
     , content::WebContentsObserver(contents)
+    ,_mWaitingReply(0)
 {
     setWorldId(worldId);
 }
@@ -86,7 +87,14 @@ void WebChannelIPCTransportHost::sendMessage(const QJsonObject &message)
     const char *rawData = doc.rawData(&size);
     content::RenderFrameHost *frame = web_contents()->GetMainFrame();
     qCDebug(log).nospace() << "sending webchannel message to " << frame << ": " << doc;
-    frame->Send(new WebChannelIPCTransport_Message(frame->GetRoutingID(), std::vector<char>(rawData, rawData + size), *m_worldId));
+    if (_mWaitingReply) {
+        WebChannelIPCTransportHost_SendMessageSync::WriteReplyParams(_mWaitingReply, std::vector<char>(rawData, rawData + size));
+        frame->Send(_mWaitingReply);
+        _mWaitingReply = 0;
+    }
+    else {
+        frame->Send(new WebChannelIPCTransport_Message(frame->GetRoutingID(), std::vector<char>(rawData, rawData + size), *m_worldId));
+    }
 }
 
 void WebChannelIPCTransportHost::setWorldId(base::Optional<uint> worldId)
@@ -116,6 +124,12 @@ void WebChannelIPCTransportHost::onWebChannelMessage(const std::vector<char> &me
     Q_EMIT messageReceived(doc.object(), this);
 }
 
+void WebChannelIPCTransportHost::onWebChannelMessageSync(const std::vector<char> &message, IPC::Message *reply)
+{
+    _mWaitingReply = reply;
+    onWebChannelMessage(message);
+}
+
 void WebChannelIPCTransportHost::RenderFrameCreated(content::RenderFrameHost *frame)
 {
     setWorldId(frame, m_worldId);
@@ -129,6 +143,7 @@ bool WebChannelIPCTransportHost::OnMessageReceived(const IPC::Message& message,
     bool handled = true;
     IPC_BEGIN_MESSAGE_MAP(WebChannelIPCTransportHost, message)
         IPC_MESSAGE_HANDLER(WebChannelIPCTransportHost_SendMessage, onWebChannelMessage)
+        IPC_MESSAGE_HANDLER_DELAY_REPLY(WebChannelIPCTransportHost_SendMessageSync, onWebChannelMessageSync)
         IPC_MESSAGE_UNHANDLED(handled = false)
     IPC_END_MESSAGE_MAP()
     return handled;
diff --git a/src/core/renderer_host/web_channel_ipc_transport_host.h b/src/core/renderer_host/web_channel_ipc_transport_host.h
index 3a814a79..f73a625b 100644
--- a/src/core/renderer_host/web_channel_ipc_transport_host.h
+++ b/src/core/renderer_host/web_channel_ipc_transport_host.h
@@ -66,6 +66,7 @@ private:
     void setWorldId(base::Optional<uint> worldId);
     void setWorldId(content::RenderFrameHost *frame, base::Optional<uint> worldId);
     void onWebChannelMessage(const std::vector<char> &message);
+    void onWebChannelMessageSync(const std::vector<char> &message, IPC::Message *reply);
 
     // WebContentsObserver
     void RenderFrameCreated(content::RenderFrameHost *frame) override;
@@ -74,6 +75,8 @@ private:
     // Empty only during construction/destruction. Synchronized to all the
     // WebChannelIPCTransports/RenderFrames in the observed WebContents.
     base::Optional<uint> m_worldId;
+
+    IPC::Message *_mWaitingReply;
 };
 
 } // namespace
